modern
 
web
 
all
 
abt
 
three
 
big
 
shifts:
 
1.
 
ai
 
first
 
dev
 
:
 
machine
 
learning
 
2.
 
edge-native
 
architectures
 
:
 
app
 
runs
 
closer
 
to
 
users
 
for
 
fast
 
performance
 
3.
 
real
 
time
 
features
 
:
 
live
 
updates,
 
collab
 
editing,
 
instant
 
notifs
 
 
ai
 
first
 
dev
 
matters
 
bec:
 
-
 
personalized
 
recommendations
 
:
 
understand
 
user
 
preferences
 
-
 
intelligent
 
search
 
:
 
understand
 
intent
 
-
 
automated
 
content
 
generation
 
:
 
dynamic
 
experiences
 
-
 
predictive
 
analytics
 
:
 
better
 
business
 
decisions
 
 
 
three
 
core
 
technologies:
 
HTML,
 
Java,
 
CSS
 
 
HTML
 
-
 
brought
 
semantic
 
elements
 
(eg.
 
<header>,
 
etc)
 
that
 
make
 
code
 
meaningful
 
and
 
accessible
 
-
 
native
 
support
 
:
 
video,
 
audio,
 
and
 
canvas
 
(
 
no
 
need
 
for
 
plugins
 
)
 
-
 
form
 
validation
 
:
 
new
 
input
 
types
 
for
 
better
 
UX
 
 
CSS
 
-
 
flexbox:
 
for
 
one
 
dimensional
 
layouts
 
-
 
grid:
 
for
 
two
 
dimensional
 
designs
 
-
 
custom
 
properties
 
(css
 
variables):
  
for
 
maintainable
 
code
 
-
 
animation:
 
dont
 
require
 
js
 
 
JavaScript
 
 
-
 
es2025+
 
features
 
:
 
for
 
modern
 
dev
 
-
 
gives
 
us
 
async/await
 
for
 
cleaner
 
asynch
 
code
 
-
 
optional
 
chaining
 
:
 
avoid
 
“cannot
 
read
 
property
 
of
 
undefined”
 
errors
 
-
 
modules
 
:
 
better
 
code
 
organization
 
 
Mobile-First
 
-
 
60%
 
of
 
web
 
traffic
 
comes
 
from
 
mobile
 
devices
 
-
 
start
 
w
 
mobile
 
to
 
prio
 
what
 
really
 
matters,
 
create
 
touch
 
friendly
 
interfaces,
 
optimize
 
performance
 
-
 
benefits:
 
faster
 
load
 
times,
 
better
 
user
 
experience,
 
cleaner
 
code
 
 
Responsive
 
Design
 
Techniques
 
1.
 
flexible
 
grids
 
:
 
percentage
 
or
 
fr
 
units
 
2.
 
fluid
 
images
 
:
 
images
 
that
 
scale
 
w
 
container
 
(max-width:
 
100%)
 
3.
 
media
 
queries
 
:
 
diff
 
styles
 
based
 
on
 
screen
 
width,
 
height,
 
or
 
orientation
 
4.
 
responsive
 
typography
 
:
 
relative
 
units
 
(rem,
 
em)
 
and
 
clamp
 
()
 
function
 
for
 
text
 
that
 
scales
 
smoothly
 
5.
 
touch
 
friendly
 
design
 
:
 
buttons
 
and
 
links
 
are
 
easy
 
to
 
tap
 
(
 
at
 
least
 
44x44
 
pixels)
 
 
Component-Driven
 
Development
 
-
 
treats
 
UI
 
elements
 
as
 
reusable,
 
self
 
contained
 
pieces
 
-
 
works
 
with
 
vanilla
 
javascript
 
-
 
benefits:
 
code
 
reusability,
 
easier
 
maintenance,
 
better
 
testing,
 
and
 
faster
 
development
 
 
1.
 
code
 
reusability
 
-
 
write
 
once,
 
use
 
everywhere
 
 
2.
 
easier
 
maintenance
 
-
 
update
 
in
 
one
 
place,
 
reflect
 
everywhere
 
3.
 
better
 
testing
 
-
 
text
 
components
 
in
 
isolation
 
4.
 
faster
 
development
 
-
 
build
 
w
 
component
 
library
 
 
Zero-Config
 
Deployments
 
and
 
Modern
 
Tooling:
 
Hot
 
Module
 
Replacement
 
-
 
see
 
changes
 
instantly
 
without
 
refreshing
 
TypeScript
 
Checking
 
-
 
happens
 
in
 
background
 
Code
 
Splitting
 
&
 
Tree
 
Shaking
 
-
 
automatic
 
optimization
 
No
 
configuration
 
File
 
-
 
works
 
out
 
of
 
the
 
box
 
 
Users
 
are
 
impatient,
 
if
 
site
 
takes
 
more
 
than
 
3
 
secs
 
to
 
load,
 
40%
 
of
 
visitors
 
will
 
bounce
 
(bounce
 
sau
 
yah)
 
 
Performance
 
optimization
 
:
 
optimizing
 
images,
 
minimizing
 
js,
 
leveraging
 
browser
 
caching
 
nd
 
cdns,
 
using
 
modern
 
CSS
 
for
 
animations,
 
implementing
 
service
 
workers
 
for
 
office
 
functionality.
 
Modern
 
CSS
 
-
 
gives
 
us
 
powerful
 
layout
 
systems,
 
custom
 
properties
 
for
 
dynamic
 
styling,
 
advanced
 
selectors,
 
and
 
animations.
 
 
 
CSS
 
Custom
 
Properties
 
(or
 
CSS
 
variables)
 
-
 
changes
 
how
 
you
 
write
 
maintainable
 
stylesheets
 
-
 
live,
 
they
 
can
 
change
 
at
 
runtime,
 
respond
 
to
 
media
 
queries,
 
and
 
be
 
manipulated
 
w
 
Javascript
 
-
 
perfect
 
for
 
theming,
 
responsive
 
design,
 
dynamic
 
interfaces
 
●
 
Live
 
updates
 
:
 
change
 
at
 
runtime
 
●
 
Media
 
query
 
responsive
 
:
 
adapt
 
to
 
context
 
●
 
Javascript
 
friendly
 
:
 
manipulate
 
dynamically
 
●
 
Perfect
 
for
 
theming
 
:
 
dark
 
mode
 
made
 
easy
 
 
Flexbox
 
-
 
one-dimensional
 
layouts
 
-
 
automatically
 
adjust
 
size
 
based
 
on
 
available
 
space
 
-
 
responsive
 
by
 
nature
 
KEY
 
FEATURES
 
●
 
display:
 
flex
 
(create
 
flex
 
container)
 
●
 
justify-content
 
(horizontal
 
alignment)
 
●
 
align-items
 
(vertical
 
alignment)
 
●
 
flex-direction
 
(row/column)
 
●
 
flex-wrap
 
(allow
 
wrapping)
 
●
 
gap
 
(spacing)
 
 
CSS
 
Grid
 
 
-
 
two
 
dimensional
 
layouts
 
-
 
lets
 
you
 
define
 
both
 
rows
 
and
 
columns
 
-
 
create
 
complex
 
layouts
 
-
 
build
 
responsive
 
design
 
using
 
auto-fit
 
and
 
minmax
 
 
Advanced
 
Selectors
 
for
 
Precise
 
Targeting
 
-
 
Modern
 
CSS
 
selectors
 
let
 
you
 
target
 
elements
 
w
 
surgical
 
precision,
 
reducing
 
the
 
need
 
for
 
extra
 
classes
 
and
 
IDs
 
 
 
Powerful
 
Selectors
 
1.
 
:nth-child()
 
targeting
 
specific
 
children
 
2.
 
:not()
 
exclude
 
elements
 
from
 
selection
 
3.
 
:has()
 
parent
 
selector
 
4.
 
::before
 
and
 
::after
 
for
 
decorative
 
elements
 
 
Responsive
 
Design
 
Patterns
 
1.
 
Column
 
Drop
 
:
 
stack
 
vertically
 
2.
 
Mostly
 
Fluid
 
:
 
adapts
 
to
 
screen
 
size
 
but
 
maintain
 
margin
 
on
 
larger
 
displays
 
3.
 
Layout
 
Shifter
 
:
 
diff
 
layouts
 
for
 
diff
 
breakpoints
 
4.
 
Tiny
 
Tweaks
 
:
 
small
 
adjustments
 
like
 
font
 
size,
 
spacing,
 
image
 
size
 
5.
 
Off
 
Canvas
 
:
 
navigation
 
hidden
 
off
 
screen
 
 
clamp
 
()
 
 
-
 
for
 
fluid
 
typography
 
 
mid
 
width
 
for:
 
(modern
 
breakpoints)
 
-
 
small
 
tablets
 
(640
 
px)
 
-
 
tablets
 
(768
 
px)
 
-
 
laptops
 
(1024
 
px)
 
-
 
desktops
 
(1280
 
px)
 
 
Animations
 
:
 
bring
 
interfaces
 
to
 
life
 
 
Transitions
 
:
 
for
 
simple
 
state
 
changes
 
like
 
hover
 
effects,
 
focus
 
states,
 
toggles
 
 
ECMAScript
 
standard
 
-
 
adds
 
new
 
features
 
that
 
make
 
language
 
more
 
powerful
 
and
 
developer
 
friendly
 
 
 
 
 
 
 
 
 
ES2025
 
Features
 
1.
 
Optional
 
Chaining
 
(?.)
 
:
 
no
 
more
 
“cannot
 
read
 
property”
 
errors,
 
safely
 
access
 
things
 
that
 
might
 
be
 
null
 
without
 
causing
 
an
 
error
 
eg.
 
const
 
city
 
=
 
user?.address?.city;
 
2.
 
Nullish
 
Coalescing
 
(??)
 
:
  
provides
 
default
 
value
 
when
 
null
 
or
 
undefined
 
 
eg.
 
const
 
name
 
=
 
user.name
 
??
 
‘
 
Guest
 
‘
 
 
Destructuring
 
and
 
Spread
 
Operators
 
1.
 
Array
 
Destructuring
 
:
 
pull
 
values
 
out
 
of
 
an
 
array
 
and
 
assign
 
them
 
to
 
variables
 
in
 
one
 
simple
 
line
 
Before
 
After
 
 
 
 
 
2.
 
Object
 
Destructuring
 
:
 
pull
 
out
 
values
 
from
 
an
 
object
 
into
 
variables
 
using
 
{}
 
 
 
 
 
 

3.
 
Spread
 
Operator
 
:
 
copies
 
all
 
values
 
from
 
an
 
existing
 
array/object.
 
 
 
Asynchronous
 
Programming
 
-
 
allows
 
u
 
to
 
perform
 
long
 
running
 
tasks
 
without
 
blocking
 
the
 
main
 
thread
 
 
JavaScript
 
-
 
single
 
threaded
 
(can
 
only
 
do
 
one
 
thing
 
at
 
a
 
time)
 
 
Promises
 
-
 
make
 
async
 
code
 
manageable
 
-
 
represents
 
a
 
value
 
that
 
might
 
not
 
available
 
yet
 
-
 
chainable
 
for
 
sequential
 
sync
 
operations
 
 
Async/Await
 
-
 
syntactic
 
sugar
 
-
 
make
 
asynch
 
code
 
look
 
and
 
behave
 
like
 
synch
 
code
 
-
 
easier
 
to
 
read,
 
write,
 
and
 
debug
 
 
 
 
 
 
 
 
 
 

Promise.race()
 
 
-
 
Returns
 
the
 
first
 
Promise
 
to
 
settle
 
 
Promise.allSettled()
 
 
-
 
Waits
 
for
 
all
 
Promises,
 
whether
 
they
 
succeed
 
or
 
fail
 
 
Promise.any()
 
 
-
 
Returns
 
the
 
first
 
Promise
 
to
 
fulfill
 
 
JavaScript
 
Design
 
Patterns
 
-
 
proven
 
solutions
 
to
 
common
 
programming
 
problems
 
-
 
make
 
your
 
code
 
more
 
maintainable,
 
scalable,
 
and
 
easier
 
to
 
understand
 
 
Functional
 
Programming
 
-
 
makes
 
code
 
more
 
predictable,
 
testable,
 
and
 
easier
 
to
 
reason
 
about
 
 
Robust
 
error
 
handling
 
 
-
 
prevents
 
crashes
 
and
 
provides
 
better
 
user
 
experience
 
 
You
 
do
 
not
 
need
 
frameworks,
 
but
 
they
 
make
 
building
 
complex
 
apps
 
easier
 
 
what
 
frameworks
 
give
 
you:
 
1.
 
component-based
 
architecture
 
(reusable
 
ui
 
pieces)
 
2.
 
state
 
management
 
(data
 
in
 
sync
 
across
 
app)
 
3.
 
virtual
 
DOM
 
(efficient
 
updates
 
wo
 
manual
 
DOM)
 
4.
 
routing
 
(navigation
 
wo
 
page
 
reloads)
 
5.
 
developer
 
tools
 
(debugging,
 
time
 
travel,
 
performance
 
profiling)
 
6.
 
ecosystem
 
(libraries,
 
plugins,
 
community
 
support)
 
 
React
 
-
 
meta
 
/
 
facebook
 
in
 
2013
 
-
 
most
 
popular
 
-
 
largest
 
ecosystem
 
-
 
large
 
apps,
 
strong
 
js
 
teams
 
 
 
 
 
Vue
 
-
 
community-driven
 
-
 
progressive
 
framework
 
-
 
gentle
 
learning
 
curve
 
-
 
any
 
size,
 
framework
 
newcomers
 
-
 
created
 
by
 
evan
 
you
 
in
 
2014
 
 
Angular
 
-
 
google
 
in
 
2010
 
-
 
full
 
featured
 
-
 
typescript
 
by
 
default
 
-
 
enterprise,
 
large
 
teams
 
 
React
 
-
 
web
 
dev
 
with
 
component
 
based
 
approach
 
and
 
virtual
 
DOM
 
-
 
it
 
is
 
a
 
library
 
-
 
ui
 
is
 
a
 
function
 
of
 
state.
 
when
 
state
 
changes,
 
react
 
updates
 
DOM
 
to
 
match
 
-
 
component
 
(reusable
 
ui
 
building
 
blocks)
 
function
 
Welcome
 
({name}){
 
        
return
 
<h1>
 
Hello,
 
{name}!
 
</h1>;
 
}
 
-
 
jsx
 
syntax
 
const
 
element
 
=
 
(
 
     
<div
 
className
 
=”container”>
 
       
<h1>
 
Welcome
 
</h1>
 
       
<p>This
 
is
 
JS</p>
 
     
</div>
 
);
 
-
 
props
 
(data
 
passing)
 
<UserCard
 
      
name
 
=
 
“John”
 
      
email
 
=
 
“
john@example.com
”
 
/>
 
-
 
state
 
(dynamic
 
data)
 
const
 
[count,
 
setCount]
 
=
 
useState(0);
 
 
<button
 
onClick={()
 
=>
 
setCount(count
 
+
 
1)}>
 
     
Clicked
 
{count}
 
times
 
</button>
 
 
React
 
Hooks
 
-
 
introduced
 
in
 
2018
 
-
 
unified
 
everything,
 
making
 
functional
 
components
 
just
 
as
 
powerful
 
as
 
class
 
components
 
-
 
make
 
react
 
code
 
more
 
reusable,
 
testable,
 
and
 
easier
 
to
 
understand
 
-
 
must
 
be
 
called
 
at
 
the
 
top
 
level
 
-
 
custom
 
hooks
 
enable
 
code
 
reuse
 
across
 
components
 
 
useState
 
-
 
State
 
Management
 
-
 
add
 
state
 
to
 
components
 
useEffect
 
-
 
Side
 
Effects
 
-
 
handle
 
side
 
effects
 
useContext
 
-
 
access
 
context
 
values
 
useRef
 
-
 
reference
 
DOM
 
elements
 
useMemo
 
-
 
memoize
 
expensive
 
calculations
 
useCallback
 
-
 
memoize
 
functions
 
 
React
 
ecosystem
 
1.
 
context
 
api
 
:
 
built
 
in,
 
good
 
for
 
simple
 
global
 
state
 
2.
 
redux
 
:
 
predictable
 
state
 
container,
 
complex
 
apps
 
3.
 
zustand
 
:
 
lightweight
 
alternative
 
to
 
redux
 
4.
 
recoil
 
:
 
atomic
 
state
 
management
 
 
 
 
 
 
Vue
 
 
-
 
you
 
can
 
adopt
 
it
 
incrementally
 
-
 
use
 
for
 
single
 
component
 
on
 
a
 
page
 
or
 
single
 
page
 
application
 
-
 
template
 
syntax
 
<template>
 
 
<div>
 
      
<h1>{{message}}</h1>
 
      
<button
 
@click=”count++”>
 
        
Clicked
 
{{count}}
 
times
 
      
</button>
 
  
</div>
 
</template>
 
Vue
 
3
 
introduced
 
composition
 
API
 
-
 
gives
 
you
 
flexibility
 
in
 
organizing
 
component
 
logic
 
-
 
this
 
is
 
optional
 
 
Vue
 
ecosystem
 
1.
 
vuex
 
:
 
official
 
state
 
management
 
(vue
 
2)
 
2.
 
pinia
 
:
 
modern
 
state
 
management
 
(vue
 
3)
 
 
Angular
 
ecosystem
 
1.
 
service
 
with
 
RxJS
 
:
 
built
 
in
 
reactive
 
state
 
management
 
2.
 
NgRx
 
:
 
redux
 
inspired
 
state
 
management
 
 
State
 
Management
 
-
 
u
 
need
 
this
 
if:
 
1.
 
multiple
 
components
 
need
 
same
 
data
 
2.
 
state
 
needs
 
persist
 
across
 
route
 
changes
 
3.
 
complex
 
state
 
logic
 
4.
 
spending
 
too
 
much
 
time
 
passing
 
 
Single
 
Page
 
Applications
 
(SPAs)
 
-
 
dont
 
reload
 
the
 
page
 
when
 
navigating
 
-
 
uses
 
client
 
side
 
routing
 
to
 
update
 
url
 
and
 
render
 
diff
 
components
 
-
 
routing
 
solutions
 
(lazy
 
loading,
 
route
 
guards,
 
nested
 
routes)
 
 